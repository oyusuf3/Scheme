
; p6.scm
; A prototype for program 6 in scheme
;
; Program 6
; CS-320-01-Fall-2021
; @date 12/08/2021
; @author Omar Yusuf
;
; Edit this file to add your documentation and function definitions.
; Leave the rest of this file unchanged.
; To run this file, you would start scheme at edoras command line prompt:
; scheme --load p6.scm, where the file is in the current directory
; and then in scheme type the load command (from the '%' prompt):
;(load "p6.scm")
;
; Defined LISTS for use with testing your functions.
(define list0 (list 'j 'k 'l 'm 'n 'o 'j) )
(define list1 (list 'a 'b 'c 'd 'e 'f 'g) )
(define list2 (list 's 't 'u 'v 'w 'x 'y 'z) )
(define list3 (list 'j 'k 'l 'm 'l 'k 'j) )
(define list4 (list 'n 'o 'p 'q 'q 'p 'o 'n) )
(define list5 '((a b) c (d e d) c (a b)) )
(define list6 '((h i) (j k) l (m n)) ) 
(define list7 '(f (a b) c (d e d) (b a) f) )
(define list8 '())
(define atm0 10)
;
; Here is a typical function definition from Sebesta Ch. 15
(define (adder lis)
  (cond
    ((null? lis) 0)
(else (+ (car lis) (adder (cdr lis))))
))
; The above five lines are the sort of definition you would need to add to
; this file if asked to define an ADDER function.
; Uncomment and complete the following five definitions. At least have ODDS
; so the program can be tested.

; odds
; returns a list containing the odd indexed elements of the passed list
(define (odds lis)
  
  ;if the list is empty itll return "USAGE: list is null"
    (cond ((null? lis)(display "USAGE: list is null") (newline))
          
          ;if the given input isnt a list itll return "USAGE: list is not a list"
          ( (not (list? lis)) (display "USAGE: list is not a list") (newline))
          
          ((null? (cdr lis)) lis)
          (else (cons (car lis) (odds (cdr (cdr lis)))))))

; (define (evenrev ...
; returns a list containing the even indexed elements of the passed list reversed
(define (evenrev lis)
  
  ;if the list is empty itll return "USAGE: list is null"
  (cond ((null? lis)(display "USAGE: list is null") (newline))
        
        ;if the given input isnt a list itll return "USAGE: list is not a list"
          ( (not (list? lis)) (display "USAGE: list is not a list") (newline))

           
          ((null? (cdr lis)) lis)
          (else (rev (evens lis)))))


; (define (penultimate ...
; return the second last element of the list
(define (penultimate lis)

  ;if the list is empty itll return "USAGE: list is null"
 (cond ((null? lis)(display "USAGE: list is null") (newline))

       ;if the given input isnt a list itll return "USAGE: list is not a list"
          ( (not (list? lis)) (display "USAGE: list is not a list") (newline))

          ;if the list is empty just return the list
          ((null? (cdr lis)) lis)
          (else (rev (evens lis))))
     (cond
           ;if the list only has two value just return a list with only the first number of the current list
            ((eq? (length lis) 1) '())
           ((eq? (length lis) 2)  (let* ( (x (car lis))) (list x)))
               (else (penultimate (cdr lis)))))

; change-head 
; returns the list generated by replacing the first element of the first list with the first element of the second list
;was given in class by mrs.kraft
(define (change-head lis1 lis2)
  (cond
    ;if the given input isnt a list itll return "USAGE: list is not a list"
    ( (or (not (list? lis1))
               (not (list? lis2)) )
      (display "Usage not a list") (newline))

    ;if the list is empty itll return "USAGE: list is null"
    ( (or (null? lis1)
          (null? lis2))
      (display "Usage is null") (newline))

    
    (else
     (cons (car lis2) (cdr lis1)))))


;(define (palindrome ...
; return #t if the list is palindrome
(define (palindrome lis)
  ;if the list is empty itll return "USAGE: list is null"
(cond ((null? lis)(display "USAGE: list is null") (newline))
      ;if the given input isnt a list itll return "USAGE: list is not a list"
          ( (not (list? lis)) (display "USAGE: list is not a list") (newline))
          (else (palindromehelper lis))))
  
  (define (palindromehelper lis)
    ;;once the list becomes empty itll return true as the list went through the whole list and it was palindrome
    (if (null? lis)(= 1 1)
        
        ;;create two values with the first and last values of the list
      (let ((lastValue (car (rev lis)))
           (firstValue (car lis)))
        
        ;;check if the values equal the same
        (and (equal? firstValue lastValue)
             (if (null? (cdr lis))
      
      (palindromehelper '())
      (palindromehelper(rev (cdr (rev (cdr lis))))))))))
     
    
       



;helper class to get evens from the list
;given from ms.kraft during class
(define (evens lis)
  (cond
    ;if the lust is empty itll return an empty list
    ( (null? lis) '())
    ( (null? (cdr lis)) '())
    (else
        (append (list (car (cdr lis))) (evens (cddr lis))))))
 

;;reverse helper class that gets the reverse of a list
(define (rev lis)
  
  ;;if the list is null itll return an empty list 
   (if (null? lis)'()

       
       (append (rev (cdr lis))
               (list (car lis)))))

  
  









